/*
 *	@file Used to created mock objects used in unit tests.
 *	Provides an easy way to change what a mocked function returns to test
 *	different code paths.
 *	Also provides an easy way to check what arguments were passed to a mocked
 *	function.
 *
 *	How to use a mock object:
 *
 *  // Original Object
 *  var mathsOperations = function() {
 *  	this.add = function(a, b) {
 *  		return a + b;
 *  	};
 *  };
 *  
 *  // Mock Object
 *  var mockMathsObject = mockObject.NewMockObject('mathsOperations');
 *  
 *  // Mock add function to return 10
 *  mockMathsObject.Mock('add', 10);
 *  
 *  console.log(mockMathsObject.add(5, 5)); // prints 10
 *  
 *  console.log(mockMathsObject.GetArguments('add')); // prints [5, 5]
 *  
 *  // Change return value
 *  mockMathsObject.ChangeReturnValue('add', 45);
 *  
 *  console.log(mockMathsObject.add(5, 5)); // prints 45
 *  
 *  The last print does not make sense but demonstrates changing the return value.
 *
 *	NOTE: Mocked objects will be an instanceof 'MockObject', not the original object.
 * 	TODO Add functionality to fake instanceof with mocked objects.
 *
 *	@author Matt Lambert
 */

'use strict';
//==============================================================================
//	Constants
//==============================================================================

var DEFAULT_CLASS = 'Object';

//==============================================================================
//	Public functions
//==============================================================================

/*  public object NewMockObject(objectClass)
 *
 * 	Create a new mock object.
 *
 * 	@param {string} objectClass - What object are you mocking. (optional)
 *      The objectClass parameter is not currently used. It is there for planned
 *      functionality in the future.
 *  @param {boolean} enforceAllFunctions - Enforce mocking of all functions (optional)
 *      The enforceAllFunctions parameter is not currently used. It is there for
 *      planned functionality in the future.
 *
 *  @return {object} new mock object
 */
module.exports.NewMockObject = function (objectClass, enforceAllFunctions) {
	if (objectClass === undefined) {
		objectClass = DEFAULT_CLASS;
	}
	if (enforceAllFunctions === undefined) {
		enforceAllFunctions = true;
	}
	var mockObject = new MockObject(objectClass, enforceAllFunctions);
	return GetProxy(mockObject);
}

//==============================================================================
//	Private functions
//==============================================================================

/*	private undefined MockObject(objectClass)
 *
 * 	Mock object.
 */
function MockObject (objectClass, enforceAllFunctions) {

	var self = this;
	var mockData = {};

	// Mock a function
	this.Mock = function (name, returnValue) {
		mockData[name] = {};
		mockData[name].returnValue = returnValue;
		mockData[name].args = {};
		this[name] = function () {
			for (var i = 0; i < arguments.length; i++) {
				mockData[name].args['arg' + (i + 1)] = arguments[i];
			}
			return mockData[name].returnValue;
		};
		return true;
	};

	// Change what you want a mocked function to return
	this.ChangeReturnValue = function (name, value) {
		if (!mockData.hasOwnProperty(name)) {
			throw new Error('Cannot change return value for function \'' + name
				+ '\' because it has not been mocked yet. Call mockObject.Mock(name)');
		}
		mockData[name].returnValue = value;
		return true;
	};

	/*  Get the arguments passed to a mocked function
	 *  Will return arguments from most recent call in the format:
	 *  { arg1 : <value>, arg2 : <value>, ... argn : <value> }
	 */
	this.GetArguments = function (name) {
		if (!mockData.hasOwnProperty(name)) {
			throw new Error('Cannot get arguments for function \'' + name
				+ '\' because it has not been mocked yet. Call mockObject.Mock(name)');
		}
		return mockData[name].args;
	};

	this.GetProxy = function (receiver, property) {
		if (receiver[property] === undefined) {
			if (enforceAllFunctions) {
				throw new Error('Cannot call unmocked function ' + property
					+ '(). Call mockObject.Mock(name)');
			}
			else {
				return self;
			}
		}
		else {
			return receiver[property];
		}
	};
}


function HandlerMaker (obj) {
  return {
    // Fundamental traps
    getOwnPropertyDescriptor: function(name) {
      var desc = Object.getOwnPropertyDescriptor(obj, name);
      // a trapping proxy's properties must always be configurable
      if (desc !== undefined) { desc.configurable = true; }
      return desc;
    },
    getPropertyDescriptor:  function(name) {
      var desc = Object.getPropertyDescriptor(obj, name); // not in ES5
      // a trapping proxy's properties must always be configurable
      if (desc !== undefined) { desc.configurable = true; }
      return desc;
    },
    getOwnPropertyNames: function() {
      return Object.getOwnPropertyNames(obj);
    },
    getPropertyNames: function() {
      return Object.getPropertyNames(obj);                // not in ES5
    },
    defineProperty: function(name, desc) {
      Object.defineProperty(obj, name, desc);
    },
    delete:       function(name) { return delete obj[name]; },   
    fix:          function() {
      if (Object.isFrozen(obj)) {
        return Object.getOwnPropertyNames(obj).map(function(name) {
          return Object.getOwnPropertyDescriptor(obj, name);
        });
      }
      // As long as obj is not frozen, the proxy won't allow itself to be fixed
      return undefined; // will cause a TypeError to be thrown
    },
   
    // derived traps
    has:          function(name) { return name in obj; },
    hasOwn:       function(name) { return Object.prototype.hasOwnProperty.call(obj, name); },
    get:          function(receiver, name) { return obj.GetProxy(receiver, name); },
    set:          function(receiver, name, val) { obj[name] = val; return true; }, // bad behavior when set fails in non-strict mode
    enumerate:    function() {
      var result = [];
      for (name in obj) { result.push(name); };
      return result;
    },
    keys: function() { return Object.keys(obj) }
  };
}

function GetProxy (obj) {
	return Proxy.create(HandlerMaker(obj));
}
