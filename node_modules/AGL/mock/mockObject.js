/*
 *	@file Used to created mock objects used in unit tests.
 *	Provides an easy way to change what a mocked function returns to test
 *	different code paths.
 *	Also provides an easy way to check what arguments were passed to a mocked
 *	function.
 *
 *	How to use a mock object:
 *
 *  // Original Object
 *  var mathsOperations = function() {
 *  	this.add = function(a, b) {
 *  		return a + b;
 *  	};
 *  };
 *  
 *  // Mock Object
 *  var mockMathsObject = mockObject.NewMockObject('mathsOperations');
 *  
 *  // Mock add function to return 10
 *  mockMathsObject.Mock('add', 10);
 *  
 *  console.log(mockMathsObject.add(5, 5)); // prints 10
 *  
 *  console.log(mockMathsObject.GetArguments('add')); // prints [5, 5]
 *  
 *  // Change return value
 *  mockMathsObject.ChangeReturnValue('add', 45);
 *  
 *  console.log(mockMathsObject.add(5, 5)); // prints 45
 *  
 *  The last print does not make sense but demonstrates changing the return value.
 *
 *	NOTE: Mocked objects will be an instanceof 'MockObject', not the original object.
 * 	TODO Add functionality to fake instanceof with mocked objects.
 *
 *	@author Matt Lambert
 */

'use strict';
//==============================================================================
//	Constants
//==============================================================================

var DEFAULT_CLASS = 'Object';

//==============================================================================
//	Public functions
//==============================================================================

/*  public object NewMockObject(objectClass)
 *
 * 	Create a new mock object.
 *
 * 	@param {string} objectClass - What object are you mocking. (optional)
 *      The objectClass parameter is not currently used. It is there for planned
 *      functionality in the future.
 *  @param {boolean} enforceAllFunctions - Enforce mocking of all functions (optional)
 *      The enforceAllFunctions parameter is not currently used. It is there for
 *      planned functionality in the future.
 *
 *  @return {object} new mock object
 */
module.exports.NewMockObject = function (objectClass, enforceAllFunctions) {
	if (typeof objectClass === 'undefined') {
		objectClass = DEFAULT_CLASS;
	}
	if (typeof enforceAllFunctions === 'undefined') {
		enforceAllFunctions = true;
	}
	return new MockObject(objectClass, enforceAllFunctions);
}

//==============================================================================
//	Private functions
//==============================================================================

/*	private undefined MockObject(objectClass)
 *
 * 	Mock object.
 */
function MockObject () {

	var self = this;
	var mockData = {};

	// Mock a function
	this.Mock = function (name, returnValue) {
		mockData[name] = {};
		mockData[name].returnValue = returnValue;
		mockData[name].args = {};
		this[name] = function () {
			for (var i = 0; i < arguments.length; i++) {
				mockData[name].args['arg' + (i + 1)] = arguments[i];
			}
			return mockData[name].returnValue;
		};
		return true;
	};

	// Change what you want a mocked function to return
	this.ChangeReturnValue = function (name, value) {
		if (!mockData.hasOwnProperty(name)) {
			throw new Error('Cannot change return value for function \'' + name
				+ '\' because it has not been mocked yet. Call mockObject.Mock(name)');
		}
		mockData[name].returnValue = value;
		return true;
	};

	/*  Get the arguments passed to a mocked function
	 *  Will return arguments from most recent call in the format:
	 *  { arg1 : <value>, arg2 : <value>, ... argn : <value> }
	 */
	this.GetArguments = function (name) {
		if (!mockData.hasOwnProperty(name)) {
			throw new Error('Cannot get arguments for function \'' + name
				+ '\' because it has not been mocked yet. Call mockObject.Mock(name)');
		}
		return mockData[name].args;
	};
}
